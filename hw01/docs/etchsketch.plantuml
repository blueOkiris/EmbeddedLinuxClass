@startuml etch-a-sketch-class

class Program {
    main(argv : List[str])
}

namespace PresentationLayer {
    class CliDisplay {
        - onLinux : bool
        - size : Tuple[int, int]
        - grid : List[str]
        - quit : bool
        - inpt : CliInputHandler

        + CliDisplay(size : Tuple[int, int])
        + start(application : Application)
        + print()
        + copyDrawBuffer(buff : DrawBuffer)
        - clearCli()
        + size() : Tuple[int, int]
        + debugInfo() : str
    }

    class CliProcessor {
        - args : List[str]
        - displaySize : Tuple[int, int]
        - startPos : Tuple[int, int]
        - success : bool
        - startPosChanged : Tuple[bool, bool]

        + CliProcessor(args : List[str])
        + successful() : bool
        + displaySize() : Tuple[int, int]
        + startPosition() : Tuple[int, int]
        - processArg(arg : str)
        - printHelp()
    }

    class CliInputHandler {
        - queue : Queue
        - updateThread : Process

        + {static} updateInput(queue : Queue)

        + CliInputHandler()
        + getKey() : str
        + start()
        + quit()
    }

    CliDisplay ..> CliInputHandler
}

namespace DomainLayer {
    class Application {
        - queue : Queue
        - updateThread : Process

        + {static} updateApplication(queue : Queue)

        + Application()
        + start()
        + quit()
        + setKey(key : str)
        + hasQuit() : bool
        + getBuffer() : DrawBuffer
    }

    class Game {
        - reset : bool
        - startPos : Tuple[int, int]
        - cursorPos : Tuple[int, int]
        - directionPressed : List[bool]
        - clearPressed : bool
        - directionReleased : List[bool]
        - clearReleased : bool
        
        + Game(startPos : Tuple[int, int])
        + update(key : str, buff : DrawBuffer) : DrawBuffer
        - updateKeys(key : str)
    }

    Application -> Game
}

namespace DataLayer {
    class DrawBuffer {
        - size : Tuple[int, int]
        - buff : List[List[bool]]

        + size() : Tuple[int, int]
        + setPoint(point : Tuple[int, int], value : bool)
        + getPoint(point : Tuple[int, int]) : bool
        + clear()
    }

    class AppState {
        + handled : bool
        + key : str
        + buffer : DrawBuffer
        + updateFunc
        + shouldQuit : bool
    }
}

Program ..> PresentationLayer.CliProcessor
Program ...> DomainLayer.Game
Program ...> DomainLayer.Application
Program ..> PresentationLayer.CliDisplay
PresentationLayer.CliDisplay ---> DomainLayer.Application
PresentationLayer.CliDisplay ---> DataLayer.DrawBuffer
DomainLayer.Application ..> DataLayer.AppState
DomainLayer.Application ..> DataLayer.DrawBuffer
DomainLayer.Game ..> DataLayer.DrawBuffer

@enduml

@startuml etch-a-sketch-seq

actor Player

participant Program

box PresentationLayer
participant CliInputHandler
participant CliDisplay
end box

box DomainLayer
participant Application
participant Game
end box

box DataLayer
entity DrawBuffer
entity AppState
end box

entity Queue

== Main Loop ==

alt main thread

Player -> Program : execute
Program -> CliDisplay : start(application)
CliDisplay -> CliInputHandler : start()
CliInputHandler -> Queue : Queue()
CliDisplay -> Application : start()
Application -> Queue : Queue()

loop !application.hasQuit()

CliDisplay -> CliInputHandler : getKey()
CliInputHandler -> Queue : get()
Queue --> CliInputHandler : key value or ''
CliInputHandler --> CliDisplay : key val or ''
CliDisplay -> Application : setKey(key)
Application -> Queue : get()
Queue --> Application : app state
Application -> AppState : state key = key
Application -> Queue : put(app state)

alt key == 'q'
CliDisplay -> Application : quit()
Application -> Queue : get()
Queue --> Application : app state
Application -> AppState : state quit = True
Application -> Queue : put(app state)
end

CliDisplay -> CliDisplay : clearCli()
CliDisplay -> Application : getBuffer()
Application -> Queue : get()
Queue --> Application : app state
Application -> AppState : state handled = True
Application -> Queue : put(app state)
Application --> CliDisplay : state buffer
CliDisplay -> CliDisplay : copyDrawBuffer

loop all rows
loop all columns
CliDisplay -> DrawBuffer : getPoint((col, row))
DrawBuffer --> CliDisplay : value at point
end
end

CliDisplay -> CliDisplay : print()
CliDisplay --> Player : output

end

else CliInputHandler process

CliInputHandler -> CliInputHandler : start update process

loop key != 'q'

CliInputHandler -> CliInputHandler : getch()
CliInputHandler -> Queue : put(key)

end

else Application process

Application -> Queue : get()
Queue --> Application : app state

alt appState.handled:
Application -> AppState : updateFunc(app state key, app state buffer)
AppState -> Game : update
Game -> DrawBuffer : set points on or off, clear, etc
DrawBuffer --> Game : updated version
Game --> AppState : updated buffer
AppState --> AppState : updated buffer
Application --> Queue : put(new app state)
end

end

@enduml
